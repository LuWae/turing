general
 - documentation & motivation everywhere (zero-alloc lexer by LL(1); recursive descent)
 - grammar pdfs in README as pictures
 - comments (doxygen)

concrete
 - simplifications
    - <> -> nothing
    - <<><>> -> nothing
    - ='p'='q' -> ='q'
    - ='p'<>='q' -> ='q'
    - main { a } a { < end } -> main { < end }
    - main { ['0'] a ['1'] a } -> main { ['0', '1'] a }
    - ='p'<<='q'>>='p'<='r'< -> <='r'<='q'
    - minimization of ranges and charvar
    - more complex minimizations (space vs. time? file format agnostic?)
       - fr('a', END) { ['a'] END > fr('a', END) } main { [#] fr('a', END) }
          -> main { ['#'] > fr('a', END)}
 - use 0x00 as blank instead of 0x5f
 - single step (one print-move) instead of entire branch atomically
 - converter to "canonical" turing machine (one print-move)
       
abstract
 - comments
 - dot call chaining
 - $$ current char??? - huge machines; maybe not
 - short name mode (s{n})

ctm
 - see where ambiguities are?
 - compressed format with dictionary?
 - mode with static allocation info
